#include <ros/ros.h>

//tf
#include <tf/tf.h>

//msg
#include <geometry_msgs/PoseStamped.h>
#include "manyears_msgs/ManyEarsTrackedAudioSource.h"

namespace {

class SourcePositionExploitation
{
    public:
	    SourcePositionExploitation(ros::NodeHandle& nh) :
			    nh_local_("~") {

		    pose_pub_ = nh.advertise < geometry_msgs::PoseStamped
				    > ("source_pose", 100);
		    pose_direction_pub = nh.advertise < geometry_msgs::PoseStamped
				    > ("source_direction", 100);

		    nh_local_.param("min_latitude", min_latitude_, -60.0);

		    tracked_sources_sub_ = nh.subscribe("sources_info", 100,
				    &SourcePositionExploitation::trackedSourcesCallback, this);

	    }
	    ~SourcePositionExploitation() {
	    }

    private:

	    void trackedSourcesCallback(
			    const manyears_msgs::ManyEarsTrackedAudioSourceConstPtr& sources_ptr)
        {
		    static const double PI = 3.14159;

		    geometry_msgs::PoseStamped pose_msg;
		    geometry_msgs::PoseStamped pose_direction;
		    pose_msg.header.stamp = sources_ptr->header.stamp;
		    pose_msg.header.frame_id = sources_ptr->header.frame_id;

		    pose_direction.header.stamp = sources_ptr->header.stamp;
		    pose_direction.header.frame_id = sources_ptr->header.frame_id;

		    int nb_sources = sources_ptr->tracked_sources.size();
		    float max_e = -1.0;
		    for (int i = 0; i < nb_sources; i++)
              {
			        if (sources_ptr->tracked_sources[i].latitude < min_latitude_)
				        continue;

                    const float& e = sources_ptr->tracked_sources[i].source_probability;
			        if (max_e < e) {
				        max_e = e;
				        pose_msg.pose.position = sources_ptr->tracked_sources[i].source_pos;
				        pose_direction.pose.position.z = 0;
				        pose_direction.pose.position.y = 0;
				        pose_direction.pose.position.x = 0;

				        tf::Quaternion target_angle;
				        target_angle.setRPY(
						        0,
						        0,
						        atan2f(pose_msg.pose.position.y, pose_msg.pose.position.x));

				        tf::quaternionTFToMsg(target_angle,pose_direction.pose.orientation);
			        }

			        tf::Quaternion r;
			        r.setRPY(0, -1.0 * sources_ptr->tracked_sources[i].latitude/ 180.0 * PI,
							    sources_ptr->tracked_sources[i].longitude / 180.0 * PI);
                    tf::quaternionTFToMsg(r, pose_msg.pose.orientation);
		      } //end of loop

		      if (max_e > 0.0) {
			      pose_pub_.publish(pose_msg);
                  pose_direction_pub.publish(pose_direction);
                 }
		 }

	    ros::Publisher pose_pub_;
	    ros::Publisher pose_direction_pub;
	    ros::Subscriber tracked_sources_sub_;
	    ros::NodeHandle nh_local_;

	    double min_latitude_;

};
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "sound_position_exploitation");
    ros::NodeHandle n;

    SourcePositionExploitation spe(n);
    ros::spin();
    return 0;
}

